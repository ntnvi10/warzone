Bandit Level 1 → Level 2

As the file is named -(hyphen) we won’t be able to read it simply by cat command. 
As cat command considers -(hyphen) as stdin/Stout. 
If we directly use cat command, it won’t be able to understand that hyphen is a file name. 
So, we will prefix the command with the path ./

cat ./-   or cat <-

----------------------------------
Bandit Level 4 → Level 5

only one of them has human readable text.

for FILE in ./-file0*; do cat $FILE \n; done
for FILE in ./-file0*; do file $FILE; done
file ./*

-----------------------------------
Bandit Level 5 → Level 6

human-readable
1033 bytes in size
not executable

find -type f -size 1033c ! -executable   #b-block, c-bytes, k-KB, M/G-MB/GB
find . -size 1033c
find -type f -size 1033c ! -executable -exec cat {} \;
{} will substitute the particular file you found into the command (cat {} in this case); the \; is to end the -exec command.)
This will run cat once for every single file rather than running a single instance of cat passing it multiple filenames which can be inefficient

find [whatever] -exec cat {} +
This will pass multiple filenames to each invocation of cat, which can be more efficient.

find [whatever] | xargs cat
find [whatever] -print0 | xargs -0 cat

find -type f -size 1033c ! -executable -print0 | xargs -0 cat

https://www.tecmint.com/xargs-command-examples/

command2 `command1`
This will send the output of command1 into command2 as command line arguments. 
Ex: cat `find . -name '*.foo' -print`

-----------------------------------
Bandit Level 6 → Level 7

stored somewhere on the server

owned by user bandit7
owned by group bandit6
33 bytes in size

find / -user bandit7 -group bandit6 -size 33c 2>/dev/null

find / -user bandit7 -group bandit6 -size 33c 2>/dev/null -print0 | xargs -0 cat
find / -type f -user bandit7 -group bandit6 -size 33c 2> /dev/null -exec cat {} \;
ssh bandit7@localhost

-----------------------------------
Bandit Level 7 → Level 8

vi Search for Word: / forward, ? backward, n/N next occurence of word

cat data.txt | grep millionth

-----------------------------------
Bandit Level 8 → Level 9

only line of text that occurs only once

sort data.txt | uniq -u
cat data.txt | sort | uniq -u

grep -o 'word' filename | wc -l

-----------------------------------
Bandit Level 9 → Level 10

in the file data.txt in one of the few human-readable strings, beginning with several ‘=’ characters.

cat data.txt | strings | grep =
strings data.txt | grep =

-----------------------------------
Bandit Level 10 → Level 11

in the file data.txt, which contains base64 encoded data

cat data.txt | base64 --decode
base64 -d data.txt

-----------------------------------
Bandit Level 11 → Level 12

in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions

banana would encrypt to onanan
cat data.txt | tr '[A-Za-z]' '[N-ZA-Mn-za-m]' # We used n-z and a-m because tr won’t continue to translate after the Z

https://www.tecmint.com/tr-command-examples-in-linux/


-----------------------------------
Bandit Level 12 → Level 13

in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. 
For this level it may be useful to create a directory under /tmp in which you can work using mkdir. 
For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv 

password file has been repeatedly compressed. 
Now to decompress we are going to need a directory with read and write permissions. 
The tmp directory in root contains the required permissions.

mkdir /tmp/pavan
cp data.txt /tmp/pavan
cd /tmp/pavan
ls
file data.txt         # On running the command, we are informed that the file is ASCII text. 
                        But as we saw earlier that it is not readable. 
xxd -r data.txt data1  # The xxd command is used in Linux to make the hexdump of a file. 
                          It is also used to reverse this process.
                         ‘r’ parameter to revert the process and provide it with a filename where it should store its output
file data1         # This tells us that it is a gzip compressed file.
mv data1 data2.gz  # first, we need to rename the file and provide it with a proper gzip extension.
gzip -d data2.gz

file data2
mv data2 data3.bz2
bzip2 -d data3.bz2
file data3
mv data3 data4.gz
gzip -d data4.gz
file data4
tar -xvf data4

-----------------------------------





